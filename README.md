# QueueTree
队列技术研究

Java的内置队列

![](https://i.imgur.com/xrJDeBT.png)

<pre>
     队列的底层一般分为3种：
         1）数组
         2）链表
         3）堆
     堆一般情况下是为了实现带有优先级特性的队列。

     ArrayBlockingQueue通过加锁的方式保证线程安全
     LinkedBlockQueue通过锁的方式实现线程安全
     ConcurrentLinkedQueue以及LinkedTransferQueue则是通过原子变量compare and swap,
          CAS这种不加锁的方式来实现的。

     通过不加锁的方式实现的队列都是无界的，无法保证队列的长度在确定的范围内；
     而加锁的方式，可以实现有界队列。
     在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；
     同时为了减少Java的垃圾回收队系统性能的影响，会尽量选择array/heap格式的数据结构，
     这样符合条件的队列筛选下来只有ArrayBlockingQueue;
</pre>

![](https://i.imgur.com/XwfvaLV.png)

<pre>
ArrayBlockingQueue在实际使用的过程中，因为加锁和伪共享等出现严重的性能问题。

     1）加锁
        现实编程过程中，加锁通常会严重的影响性能。线程会因为竞争不到锁而被挂起，等锁被释放
        的时候，线程又会被恢复，这个过程中存在很大的开销，并且通常会有较长时间的中断，因为
        当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟
        执行，例如发生了缺页中断，调度延迟或者其他类似情况，那么所有需要这个锁的线程都无法
        执行下去。如果被阻塞的线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级
        反转。

        Distruptor论文中讲述了一个实验：
            .这个测试程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次
            .机器环境： 2.4G 6核
            .运算：64位的计算器累加5亿次

        CAS操作比单线程无锁慢了1个数量级；
        有锁且多线程并发的情况下，速度比单线程无锁情况下慢3个数量级；
        
        单线程情况下，不加锁的性能 > CAS操作的性能 > 加锁的性能

        在多线程情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的
        性能，前者大约是后者的8倍。
</pre>

<pre>
关于锁与CAS

      锁：
           采取加锁的方式，默认线程会发生冲突，访问数据时，先加上锁再访问，访问之后再解锁。
      通过锁定一个临界区，同时只有一个线程进入。

      原子变量
           原子变量能够保证操作的原子性，在某个任务执行的时候，要么全部成功，要么全部失败
      回滚，恢复到执行之前的初态，不存在初态和成功之间的中间状态。例如CAS操作，要么比较并
      交换成功，要么比较并交换失败。由CPU保证原子性。

           通过原子变量可以实现线程安全，执行某个任务的时候，先假定不会有冲突，若发生冲突，
      则直接执行成功；当发生冲突的时候，则实行失败，回滚再重新操作，知道不发生冲突。

 
      在高度竞争的情况下，锁的性能将超过原子变量的性能，但是更真实的竞争情况下，原子变量的
      性能将超过锁的性能。同时原子变量不会有死锁等活跃性问题。
</pre>

![](https://i.imgur.com/znaAdzF.png)

CPU访问不同层级数据的时间

![](https://i.imgur.com/usZJVec.png)

![](https://i.imgur.com/wLRkAoF.png)

<pre>
伪共享
      当CPU执行运算的时候，它先去L1查找所需的数据，再去L2,然后是L3，如果最后这些缓存中都
   没有，所需的数据就要去主内存拿，走的越远，运算耗费的时间久越长。所以如果你在做一些很频繁
   的事，你要尽量确保数据保存在L1缓存中。

      可见CPU读取主存中的数据会比从L1中读取慢了2个数量级。

   ArrayBlockingQueue有三个成员变量：
      1）takeIndex:需要被取走的元素下标
      2）putIndex可被元素插入的位置的下标
      3）count：队列中元素的数量

   如上图所示：
       当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者
   线程的缓存行无效，需要从主存中重新读取。

       这种无法充分利用缓存航特性的现象，称为伪共享。
</pre>

<pre>
Distruptor的设计方案

   Distruptor通过以下设计来解决队列速度慢的问题：
      1）环形数组结构
         为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好
      2）元素位置定位
         数组长度为2的n次方，通过位运算，加快定位的速度。下表采取递增的形式。不用担心index
         溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。
      3）无锁设计
         每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接
         在该位置写入或者读取数据
</pre>